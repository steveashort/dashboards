
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Dark Team Hierarchy</title>
    <!-- Expects a global `teamData` object in data.js with hierarchical structure and `engagement` at each node -->
    <script src="team_members.js"></script>

    <style>
        /* ==========================================================
           1) DARK THEME VARIABLES
           ----------------------------------------------------------
           - Centralised variables for quick theming changes.
           ========================================================== */
        :root {
            --bg-color: #121212;
            --sidebar-bg: #1e1e1e;
            --card-bg: #1e1e1e;
            --card-border: #333;
            --text-main: #e0e0e0;
            --text-muted: #a0a0a0;
            --accent: #3498db;
            --location-color: #2ecc71;  /* Green for location */
            --engagement-color: #9b59b6; /* Purple for engagement */
            --line-color: #444;
            --hover-bg: #252525;
        }

        /* ==========================================================
           2) PAGE LAYOUT
           ========================================================== */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar (left) */
        .sidebar {
            width: 260px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid #333;
            padding: 20px;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }
        .sidebar h3 { margin-top: 0; font-size: 18px; color: var(--text-main); margin-bottom: 20px; }
        .control-group { margin-bottom: 20px; }
        .control-group label { display: block; font-size: 12px; color: var(--text-muted); margin-bottom: 8px; font-weight: 600; text-transform: uppercase; }

        select {
            width: 100%; padding: 10px;
            background: #2d2d2d; color: white;
            border: 1px solid #444; border-radius: 4px;
            outline: none; cursor: pointer;
        }
        select:focus { border-color: var(--accent); }
        .help-text { font-size: 11px; color: var(--text-muted); margin-top: 6px; }

        .btn-group { display: flex; flex-direction: column; gap: 10px; }
        button {
            padding: 10px; border: none; border-radius: 4px;
            cursor: pointer; font-weight: 600; font-size: 13px;
            transition: all 0.2s;
        }
        .btn-expand { background-color: var(--accent); color: white; }
        .btn-expand:hover { background-color: #2980b9; }
        .btn-reset { background-color: #333; color: #ccc; }
        .btn-reset:hover { background-color: #444; }

        /* Main content (right) */
        .main-content {
            margin-left: 260px;
            flex: 1;
            padding: 40px;
            overflow-x: auto;
        }

        /* ==========================================================
           3) TREE LINES
           ========================================================== */
        ul { list-style: none; padding-left: 20px; margin: 0; position: relative; }
        ul.children-list {
            border-left: 2px solid var(--line-color);
            margin-left: 15px; padding-left: 30px;
        }
        li { margin: 15px 0; position: relative; }

        /* Horizontal connector line to parent */
        li::before {
            content: ''; position: absolute; top: 32px; left: -32px;
            width: 30px; height: 2px; background-color: var(--line-color);
        }
        .main-tree > ul > li::before { display: none; }
        .main-tree > ul > li > ul.children-list { margin-left: 25px; }

        /* ==========================================================
           4) NODE CARD
           ========================================================== */
        .node-card {
            display: flex; align-items: center;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            padding: 12px 15px;
            border-radius: 6px;
            width: fit-content; min-width: 450px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        .node-card:hover {
            border-color: var(--accent);
            background-color: var(--hover-bg);
            transform: translateX(5px);
        }
        .node-card.has-children { border-left: 4px solid var(--accent); }

        /* Filter match highlight */
        .node-card.matched {
            border: 1px solid #27ae60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.2);
        }
        .node-card.matched .name { color: #2ecc71; }

        /* ==========================================================
           5) TEXT & PILLS
           ========================================================== */
        .info { display: flex; flex-direction: column; width: 100%; }

        /* Top Row: Name + Engagement + Location */
        .top-row { display: flex; align-items: center; gap: 10px; margin-bottom: 4px; }
        .name { font-weight: 700; font-size: 16px; color: var(--text-main); }

        /* Engagement pill */
        .engagement-pill {
            font-size: 11px;
            color: var(--engagement-color);
            border: 1px solid var(--engagement-color);
            padding: 1px 6px;
            border-radius: 10px;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        /* Location pill */
        .location-pill {
            font-size: 11px;
            color: var(--location-color);
            border: 1px solid var(--location-color);
            padding: 1px 6px;
            border-radius: 10px;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .role { font-size: 12px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; margin-bottom: 8px; }
        .tags-row { display: flex; flex-wrap: wrap; gap: 6px; }

        .pill {
            display: inline-block; padding: 3px 8px; border-radius: 4px;
            font-size: 10px; font-weight: 700; color: white;
            text-transform: uppercase; letter-spacing: 0.5px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        /* Misc utilities */
        .toggle-btn {
            margin-right: 15px; width: 24px; height: 24px;
            display: flex; align-items: center; justify-content: center;
            border: 1px solid #444; border-radius: 4px;
            background: #252525; color: #aaa;
            font-size: 16px; font-weight: bold;
        }
        .toggle-btn:hover { border-color: var(--accent); color: var(--accent); }

        .hidden { display: none; }
        .hidden-node { display: none !important; }

        /* Tooltip */
        .tooltip {
            visibility: hidden; width: 250px;
            background-color: #000; color: #fff; border: 1px solid #333;
            padding: 10px; border-radius: 4px;
            position: absolute; z-index: 100;
            top: 50%; left: 100%; margin-left: 15px;
            transform: translateY(-50%);
            font-size: 12px; line-height: 1.4;
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .node-card:hover .tooltip { visibility: visible; opacity: 1; }
    </style>
</head>
<body>

<aside class="sidebar">
    <h3>Org Viewer</h3>

    <div class="control-group">
        <label>Filter by Role</label>
        <select id="roleFilter" onchange="applyFilter()">
            <option value="ALL">Show All</option>
        </select>
    </div>

    <div class="control-group">
        <label>Filter by Location</label>
        <select id="locFilter" onchange="applyFilter()">
            <option value="ALL">Show All</option>
        </select>
    </div>

    <div class="control-group">
        <label>Filter by Skill/Tag (multi-select)</label>
        <!-- Multiple selection enabled; AND logic across selected tags -->
        <select id="tagFilter" multiple size="8" onchange="applyFilter()">
            <!-- Options injected dynamically -->
        </select>
        <div class="help-text">Hold <strong>Ctrl</strong>/<strong>Cmd</strong> to select multiple. Matching uses <strong>AND</strong>.</div>
    </div>

    <div class="control-group">
        <label>Actions</label>
        <div class="btn-group">
            <button class="btn-expand" onclick="expandAll()">Expand All</button>
            <button class="btn-reset" onclick="collapseAll()">Collapse All</button>
        </div>
    </div>
</aside>

<div class="main-content">
    <div id="tree-container" class="main-tree"></div>
</div>

<script>
    /**
     * ==========================================================
     * SAFETY: data availability
     * ==========================================================
     */
    if (typeof teamData === 'undefined') {
        document.getElementById('tree-container').innerHTML =
            "<h3 style='color:red'>Error: data.js not found.</h3>";
    }

    /**
     * ==========================================================
     * UTILS
     * ==========================================================
     */

    // Deterministic color per string (good variety, readable)
    function stringToColor(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        const h = Math.abs(hash) % 360; // hue between 0-359
        return `hsl(${h}, 65%, 40%)`;
    }

    // Fallback engagement derivation if not present
    function deriveEngagement(description = "", tags = []) {
        const text = String(description).toLowerCase();
        const tagSet = new Set((tags || []).map(t => String(t).toLowerCase().trim()));
        if (text.includes("kingfisher")) return "Kingfisher";
        if (text.includes("tcs")) return "TCS";
        if (text.includes("ust")) return "UST";
        if (tagSet.has("kingfisher")) return "Kingfisher";
        if (tagSet.has("tcs")) return "TCS";
        if (tagSet.has("ust")) return "UST";
        return null;
    }

    /**
     * ==========================================================
     * BUILD TREE
     * ==========================================================
     */
    const container = document.getElementById('tree-container');
    const rootUl = document.createElement('ul');
    container.appendChild(rootUl);

    buildNode(teamData, rootUl);
    populateDropdowns();

    function buildNode(data, parentElement) {
        const li = document.createElement('li');
        li.className = "tree-item";

        // --- A) NORMALISE INPUTS ---
        const rawTags = Array.isArray(data.tags) ? data.tags.slice() : [];
        rawTags.sort((a, b) => a.localeCompare(b));

        // Prefer provided engagement; fallback to derivation if missing
        const engagement = data.engagement ?? deriveEngagement(data.description, rawTags);

        // Location (supports both 'Location' and 'location' keys)
        const rawLoc = data.Location || data.location || "";
        const locLabel = rawLoc || "Unknown";

        const roleLabel = data.role || "Unknown";

        // --- B) DATASETS FOR FILTERING ---
        // Add Location and Engagement into the tag tokens to enable tag-based filtering
        const upperTags = rawTags.map(t => t.toUpperCase());
        const tagTokens = new Set(upperTags);
        if (locLabel) tagTokens.add(locLabel.toUpperCase());
        if (engagement) tagTokens.add(String(engagement).toUpperCase());

        li.dataset.tags = Array.from(tagTokens).join(',');
        li.dataset.location = locLabel.toUpperCase();
        li.dataset.role = roleLabel.toUpperCase();
        li.dataset.engagement = (engagement ? String(engagement).toUpperCase() : ""); // not used directly, but available

        // --- C) RENDER CARD ---
        const hasChildren = Array.isArray(data.children) && data.children.length > 0;

        const card = document.createElement('div');
        card.className = hasChildren ? 'node-card has-children' : 'node-card';

        const iconHtml = hasChildren
            ? '<div class="toggle-btn">−</div>'
            : '<div style="width:24px; margin-right:15px;"></div>';

        // Tag pills (do NOT include location or engagement here; keep UI clean)
        let pillsHtml = "";
        rawTags.forEach(tag => {
            const color = stringToColor(tag);
            pillsHtml += `<span class="pill" style="background-color: ${color}">${tag}</span>`;
        });

        // Engagement pill (shown in top row, before location)
        const engagementHtml = engagement
            ? `<span class="engagement-pill">${engagement}</span>`
            : '';

        // Location pill
        const locationHtml = rawLoc
            ? `<span class="location-pill">${rawLoc}</span>`
            : '';

        card.innerHTML = `
            ${iconHtml}
            <div class="info">
                <div class="top-row">
                    <span class="name">${data.name}</span>
                    ${engagementHtml}
                    ${locationHtml}
                </div>
                <span class="role">${roleLabel}</span>
                <div class="tags-row">
                    ${pillsHtml}
                </div>
            </div>
            <div class="tooltip">${data.description || ""}</div>
        `;

        li.appendChild(card);

        // --- D) CHILDREN (RECURSION) ---
        if (hasChildren) {
            const childUl = document.createElement('ul');
            childUl.className = 'children-list';

            data.children.forEach(child => buildNode(child, childUl));
            li.appendChild(childUl);

            card.onclick = function (e) {
                e.stopPropagation();
                const btn = card.querySelector('.toggle-btn');
                if (childUl.classList.contains('hidden')) {
                    childUl.classList.remove('hidden');
                    btn.textContent = "−";
                } else {
                    childUl.classList.add('hidden');
                    btn.textContent = "+";
                }
            };
        }

        parentElement.appendChild(li);
    }

    /**
     * ==========================================================
     * POPULATE DROPDOWNS
     * - Tags: includes skills + locations + engagements
     * - Locations: distinct list from nodes
     * - Roles: distinct list from nodes
     * ==========================================================
     */
    function populateDropdowns() {
        const allTags = new Set();
        const allLocs = new Set();
        const allRoles = new Set();

        function collect(node) {
            // 1) Skills/Tags
            if (Array.isArray(node.tags)) {
                node.tags.forEach(t => allTags.add(String(t).toUpperCase()));
            }
            // 2) Location as additional tag token and a separate location
            const l = node.Location || node.location;
            if (l) {
                allLocs.add(String(l).toUpperCase());
                allTags.add(String(l).toUpperCase());
            }
            // 3) Engagement as additional tag token
            const eng = node.engagement ?? deriveEngagement(node.description, node.tags || []);
            if (eng) {
                allTags.add(String(eng).toUpperCase());
            }
            // 4) Role
            if (node.role) allRoles.add(String(node.role).toUpperCase());

            // Recurse
            if (Array.isArray(node.children)) node.children.forEach(collect);
        }
        collect(teamData);

        function fillSelect(id, set, { includeAll = true } = {}) {
            const select = document.getElementById(id);
            // Clear any existing except first (if present)
            while (select.options.length > 0) select.remove(0);

            if (includeAll) {
                const optAll = document.createElement('option');
                optAll.value = "ALL";
                optAll.textContent = "Show All";
                // For multi-select, we do not preselect ALL; empty selection means ALL
                select.appendChild(optAll);
            }

            Array.from(set).sort().forEach(val => {
                const opt = document.createElement('option');
                opt.value = val;
                opt.textContent = val;
                select.appendChild(opt);
            });
        }

        // Tag filter is multi-select; we still include an "ALL" option for clarity
        fillSelect('tagFilter', allTags, { includeAll: true });
        fillSelect('locFilter', allLocs, { includeAll: true });
        fillSelect('roleFilter', allRoles, { includeAll: true });

        // Ensure no tag is selected initially (meaning ALL)
        const tagFilter = document.getElementById('tagFilter');
        Array.from(tagFilter.options).forEach(opt => (opt.selected = false));
    }

    /**
     * ==========================================================
     * FILTERING
     * - Tags filter uses AND logic across selected tags
     * - Location & Role filters are single-select ANDed with tags
     * - Path preservation: shows parents if any descendant matches
     * ==========================================================
     */
    function applyFilter() {
        const tagFilterEl = document.getElementById('tagFilter');
        const selectedTags = Array.from(tagFilterEl.selectedOptions).map(o => o.value);

        const selectedLoc = document.getElementById('locFilter').value;
        const selectedRole = document.getElementById('roleFilter').value;

        const rootLi = document.querySelector('.tree-item');

        // Helper: case-insensitive containment
        function nodeMatches(li) {
            const nodeTags = (li.dataset.tags || "");
            const nodeLoc = li.dataset.location || "UNKNOWN";
            const nodeRole = li.dataset.role || "UNKNOWN";

            // Tags: if none selected OR 'ALL' selected => tags pass
            const tagsPass =
                selectedTags.length === 0 ||
                selectedTags.includes("ALL") ||
                selectedTags.every(tag => nodeTags.includes(tag));

            // Location: pass if ALL or exact match
            const locPass = (selectedLoc === "ALL") || (nodeLoc === selectedLoc);

            // Role: pass if ALL or exact match
            const rolePass = (selectedRole === "ALL") || (nodeRole === selectedRole);

            return tagsPass && locPass && rolePass;
        }

        // Reset visuals first
        document.querySelectorAll('.tree-item').forEach(el => el.classList.remove('hidden-node'));
        document.querySelectorAll('.node-card').forEach(el => el.classList.remove('matched'));

        // If everything is ALL and no tags selected, no filtering
        const noFilter =
            (selectedTags.length === 0 || selectedTags.includes("ALL")) &&
            selectedLoc === "ALL" &&
            selectedRole === "ALL";

        if (noFilter) {
            return;
        }

        // Recursive match check; shows a node if it or any child matches
        function checkNode(li) {
            const selfMatch = nodeMatches(li);
            let childMatch = false;

            const childrenUl = li.querySelector(':scope > ul.children-list');
            if (childrenUl) {
                const childLis = Array.from(childrenUl.children).filter(el => el.tagName === 'LI');
                childLis.forEach(childLi => {
                    if (checkNode(childLi)) childMatch = true;
                });
            }

            const card = li.querySelector('.node-card');

            if (selfMatch || childMatch) {
                li.classList.remove('hidden-node');
                if (selfMatch) card.classList.add('matched');
                else card.classList.remove('matched');

                // If a descendant matched, expand to reveal the path
                if (childrenUl && childMatch) {
                    childrenUl.classList.remove('hidden');
                    const btn = card.querySelector('.toggle-btn');
                    if (btn) btn.textContent = "−";
                }
                return true;
            } else {
                li.classList.add('hidden-node');
                card.classList.remove('matched');
                return false;
            }
        }

        checkNode(rootLi);
    }

    function expandAll() {
        document.querySelectorAll('.children-list').forEach(ul => ul.classList.remove('hidden'));
        document.querySelectorAll('.toggle-btn').forEach(btn => (btn.textContent = "−"));
    }

    function collapseAll() {
        document.querySelectorAll('.children-list').forEach(ul => ul.classList.add('hidden'));
        document.querySelectorAll('.toggle-btn').forEach(btn => (btn.textContent = "+"));
    }
</script>

</body>
</html>
